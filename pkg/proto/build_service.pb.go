// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/proto/build_service.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BuildRequest struct {
	// Required: the branch ID targetted.
	BranchId uint64 `protobuf:"varint,1,opt,name=branch_id,json=branchId,proto3" json:"branch_id,omitempty"`
	// Required: a list of acceptable target platforms
	Target []Target `protobuf:"varint,2,rep,packed,name=target,proto3,enum=tapioca.Target" json:"target,omitempty"`
	// Optional: The client's local build ID. This should only be unset when the
	// local client is freshly installing the targetted game.
	LocalBuildId         []byte   `protobuf:"bytes,3,opt,name=local_build_id,json=localBuildId,proto3" json:"local_build_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuildRequest) Reset()         { *m = BuildRequest{} }
func (m *BuildRequest) String() string { return proto.CompactTextString(m) }
func (*BuildRequest) ProtoMessage()    {}
func (*BuildRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe5db27ac60bc92, []int{0}
}

func (m *BuildRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildRequest.Unmarshal(m, b)
}
func (m *BuildRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildRequest.Marshal(b, m, deterministic)
}
func (m *BuildRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildRequest.Merge(m, src)
}
func (m *BuildRequest) XXX_Size() int {
	return xxx_messageInfo_BuildRequest.Size(m)
}
func (m *BuildRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuildRequest proto.InternalMessageInfo

func (m *BuildRequest) GetBranchId() uint64 {
	if m != nil {
		return m.BranchId
	}
	return 0
}

func (m *BuildRequest) GetTarget() []Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *BuildRequest) GetLocalBuildId() []byte {
	if m != nil {
		return m.LocalBuildId
	}
	return nil
}

type BuildResponse struct {
	// Required: The ID corresponding to the latest build. This should be stored
	// persistently by the client, alongside any manifest results included to
	// reduce the amount of data checked.
	BuildId []byte `protobuf:"bytes,1,opt,name=build_id,json=buildId,proto3" json:"build_id,omitempty"`
	// Required: A checksum value for verifying if the resultant manifest on the
	//           client's end matches the remote one.
	ManifestChecksum uint64 `protobuf:"varint,2,opt,name=manifest_checksum,json=manifestChecksum,proto3" json:"manifest_checksum,omitempty"`
	// Optional: Contains infromation to recreate the latest build on the client.
	//
	// The following rules determine which field is set:
	//  * The request's local_build_id is not set: full manifest.
	//  * The local_build_id is not found on the remote server: full manifest.
	//  * The local build has a "small" diff with the latest build: manifest diff.
	//  * The local_build_id matches the server's latest build: neither.
	//  * Any other case: full manifest.
	//
	// A diff between two builds is considered "too big" when more than a
	// configured threshold of blocks have changed within a manifest. This is to
	// avoid potential diff mismatches and addiitonal round trips. When diffs get
	// too large, there's not much to gain against sending the full manifest.
	//
	// If neither field is set, the local client has an up to date client, but
	// should still verify it's validity with manifest_checksum.
	//
	// Types that are valid to be assigned to Changes:
	//	*BuildResponse_Manifest
	//	*BuildResponse_ManifestDiff
	Changes              isBuildResponse_Changes `protobuf_oneof:"changes"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BuildResponse) Reset()         { *m = BuildResponse{} }
func (m *BuildResponse) String() string { return proto.CompactTextString(m) }
func (*BuildResponse) ProtoMessage()    {}
func (*BuildResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fe5db27ac60bc92, []int{1}
}

func (m *BuildResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildResponse.Unmarshal(m, b)
}
func (m *BuildResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildResponse.Marshal(b, m, deterministic)
}
func (m *BuildResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildResponse.Merge(m, src)
}
func (m *BuildResponse) XXX_Size() int {
	return xxx_messageInfo_BuildResponse.Size(m)
}
func (m *BuildResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BuildResponse proto.InternalMessageInfo

func (m *BuildResponse) GetBuildId() []byte {
	if m != nil {
		return m.BuildId
	}
	return nil
}

func (m *BuildResponse) GetManifestChecksum() uint64 {
	if m != nil {
		return m.ManifestChecksum
	}
	return 0
}

type isBuildResponse_Changes interface {
	isBuildResponse_Changes()
}

type BuildResponse_Manifest struct {
	Manifest *ManifestProto `protobuf:"bytes,3,opt,name=manifest,proto3,oneof"`
}

type BuildResponse_ManifestDiff struct {
	ManifestDiff *ManifestDiffProto `protobuf:"bytes,4,opt,name=manifest_diff,json=manifestDiff,proto3,oneof"`
}

func (*BuildResponse_Manifest) isBuildResponse_Changes() {}

func (*BuildResponse_ManifestDiff) isBuildResponse_Changes() {}

func (m *BuildResponse) GetChanges() isBuildResponse_Changes {
	if m != nil {
		return m.Changes
	}
	return nil
}

func (m *BuildResponse) GetManifest() *ManifestProto {
	if x, ok := m.GetChanges().(*BuildResponse_Manifest); ok {
		return x.Manifest
	}
	return nil
}

func (m *BuildResponse) GetManifestDiff() *ManifestDiffProto {
	if x, ok := m.GetChanges().(*BuildResponse_ManifestDiff); ok {
		return x.ManifestDiff
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BuildResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BuildResponse_OneofMarshaler, _BuildResponse_OneofUnmarshaler, _BuildResponse_OneofSizer, []interface{}{
		(*BuildResponse_Manifest)(nil),
		(*BuildResponse_ManifestDiff)(nil),
	}
}

func _BuildResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BuildResponse)
	// changes
	switch x := m.Changes.(type) {
	case *BuildResponse_Manifest:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Manifest); err != nil {
			return err
		}
	case *BuildResponse_ManifestDiff:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ManifestDiff); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BuildResponse.Changes has unexpected type %T", x)
	}
	return nil
}

func _BuildResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BuildResponse)
	switch tag {
	case 3: // changes.manifest
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ManifestProto)
		err := b.DecodeMessage(msg)
		m.Changes = &BuildResponse_Manifest{msg}
		return true, err
	case 4: // changes.manifest_diff
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ManifestDiffProto)
		err := b.DecodeMessage(msg)
		m.Changes = &BuildResponse_ManifestDiff{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BuildResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BuildResponse)
	// changes
	switch x := m.Changes.(type) {
	case *BuildResponse_Manifest:
		s := proto.Size(x.Manifest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BuildResponse_ManifestDiff:
		s := proto.Size(x.ManifestDiff)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*BuildRequest)(nil), "tapioca.BuildRequest")
	proto.RegisterType((*BuildResponse)(nil), "tapioca.BuildResponse")
}

func init() { proto.RegisterFile("pkg/proto/build_service.proto", fileDescriptor_6fe5db27ac60bc92) }

var fileDescriptor_6fe5db27ac60bc92 = []byte{
	// 317 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0x5f, 0x4b, 0xc3, 0x30,
	0x14, 0xc5, 0xed, 0x36, 0xf7, 0xe7, 0xae, 0x9b, 0x1a, 0x70, 0xc4, 0x89, 0x30, 0x86, 0xe0, 0x40,
	0xd8, 0x60, 0xfa, 0x2e, 0x4e, 0xc1, 0x0d, 0x14, 0xa4, 0xf8, 0xe4, 0x4b, 0x49, 0x93, 0x74, 0x0b,
	0xeb, 0x3f, 0x9b, 0xd4, 0x07, 0xbf, 0xaa, 0x5f, 0x46, 0x96, 0xb4, 0x71, 0xe8, 0x53, 0xe1, 0x77,
	0xcf, 0xe9, 0x39, 0xf7, 0x06, 0x2e, 0xb2, 0xed, 0x7a, 0x96, 0xe5, 0xa9, 0x4a, 0x67, 0x41, 0x21,
	0x22, 0xe6, 0x4b, 0x9e, 0x7f, 0x0a, 0xca, 0xa7, 0x9a, 0xa1, 0x96, 0x22, 0x99, 0x48, 0x29, 0x19,
	0xe2, 0x5f, 0x5d, 0x4c, 0x12, 0x11, 0x72, 0xa9, 0x8c, 0x64, 0xfc, 0x05, 0xee, 0x62, 0xe7, 0xf4,
	0xf8, 0x47, 0xc1, 0xa5, 0x42, 0xe7, 0xd0, 0x09, 0x72, 0x92, 0xd0, 0x8d, 0x2f, 0x18, 0x76, 0x46,
	0xce, 0xa4, 0xe1, 0xb5, 0x0d, 0x58, 0x31, 0x74, 0x05, 0x4d, 0x45, 0xf2, 0x35, 0x57, 0xb8, 0x36,
	0xaa, 0x4f, 0xfa, 0xf3, 0xa3, 0x69, 0x19, 0x30, 0x7d, 0xd3, 0xd8, 0x2b, 0xc7, 0xe8, 0x12, 0xfa,
	0x51, 0x4a, 0x49, 0xe4, 0x9b, 0x56, 0x82, 0xe1, 0xfa, 0xc8, 0x99, 0xb8, 0x9e, 0xab, 0xa9, 0x0e,
	0x5c, 0xb1, 0xf1, 0xb7, 0x03, 0xbd, 0x32, 0x5c, 0x66, 0x69, 0x22, 0x39, 0x3a, 0x83, 0xb6, 0x75,
	0x38, 0xda, 0xd1, 0x0a, 0x8c, 0x18, 0x5d, 0xc3, 0x49, 0x55, 0xdd, 0xa7, 0x1b, 0x4e, 0xb7, 0xb2,
	0x88, 0x71, 0x4d, 0x17, 0x3c, 0xae, 0x06, 0x0f, 0x25, 0x47, 0xb7, 0xd0, 0xae, 0x98, 0x4e, 0xee,
	0xce, 0x07, 0xb6, 0xea, 0x4b, 0x39, 0x78, 0xdd, 0xed, 0xbf, 0x3c, 0xf0, 0xac, 0x12, 0xdd, 0x43,
	0xcf, 0x46, 0x30, 0x11, 0x86, 0xb8, 0xa1, 0xad, 0xc3, 0x7f, 0xd6, 0x47, 0x11, 0x86, 0x95, 0xdd,
	0x8d, 0xf7, 0xe0, 0xa2, 0x03, 0x2d, 0xba, 0x21, 0xc9, 0x9a, 0xcb, 0xf9, 0x12, 0x0e, 0xf5, 0x72,
	0xe8, 0x0e, 0xfa, 0x4f, 0x5c, 0x3d, 0x13, 0xc5, 0xa5, 0x32, 0xe4, 0xd4, 0xfe, 0x71, 0xff, 0xf6,
	0xc3, 0xc1, 0x5f, 0x6c, 0xae, 0xb2, 0xe8, 0xbe, 0x77, 0xec, 0xfb, 0x05, 0x4d, 0xfd, 0xb9, 0xf9,
	0x09, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x47, 0x1f, 0xfa, 0xfb, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BuildClient is the client API for Build service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BuildClient interface {
	GetLatestBuild(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (*BuildResponse, error)
}

type buildClient struct {
	cc *grpc.ClientConn
}

func NewBuildClient(cc *grpc.ClientConn) BuildClient {
	return &buildClient{cc}
}

func (c *buildClient) GetLatestBuild(ctx context.Context, in *BuildRequest, opts ...grpc.CallOption) (*BuildResponse, error) {
	out := new(BuildResponse)
	err := c.cc.Invoke(ctx, "/tapioca.Build/GetLatestBuild", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuildServer is the server API for Build service.
type BuildServer interface {
	GetLatestBuild(context.Context, *BuildRequest) (*BuildResponse, error)
}

func RegisterBuildServer(s *grpc.Server, srv BuildServer) {
	s.RegisterService(&_Build_serviceDesc, srv)
}

func _Build_GetLatestBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildServer).GetLatestBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tapioca.Build/GetLatestBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildServer).GetLatestBuild(ctx, req.(*BuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Build_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tapioca.Build",
	HandlerType: (*BuildServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLatestBuild",
			Handler:    _Build_GetLatestBuild_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/build_service.proto",
}
